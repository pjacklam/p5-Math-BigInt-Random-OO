  
.\" Automatically generated by Pod::Man 2.22 (Pod::Simple 3.07)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\" ========================================================================
.\"
.IX Title "Math::BigInt::Random::OO 3"
.TH Math::BigInt::Random::OO 3 "2010-02-23" "perl v5.10.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Math::BigInt::Random::OO \- generate uniformly distributed Math::BigInt objects
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use Math::BigInt::Random::OO;
\&
\&  # Random numbers between 1e20 and 2e30:
\&
\&  my $gen = Math::BigInt::Random::OO \-> new(min => "1e20",
\&                                            min => "2e30");
\&  $x = $gen \-> generate();      # one number
\&  $x = $gen \-> generate(1);     # ditto
\&  @x = $gen \-> generate(100);   # 100 numbers
\&
\&  # Random numbers with size fitting 20 hexadecimal digits:
\&
\&  my $gen = Math::BigInt::Random::OO \-> new(length => 20,
\&                                            base => 16);
\&  @x = $gen \-> generate(100);
.Ve
.SH "ABSTRACT"
.IX Header "ABSTRACT"
Math::BigInt::Random::OO is a module for generating arbitrarily large random
integers from a discrete, uniform distribution. The numbers are returned as
Math::BigInt objects.
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Math::BigInt::Random::OO is a module for generating arbitrarily large random
integers from a discrete, uniform distribution. The numbers are returned as
Math::BigInt objects.
.SH "CONSTRUCTORS"
.IX Header "CONSTRUCTORS"
.IP "\s-1CLASS\s0 \-> new ( ... )" 4
.IX Item "CLASS -> new ( ... )"
Returns a new \f(CW\*(C`Math::BigInt::Random::OO\*(C'\fR random number generator object. The
arguments are given in the \*(L"hash style\*(R", as shown in the following example
which constructs a generator for random numbers in the range from \-2 to 3,
inclusive.
.Sp
.Vb 2
\&  my $gen = Math::BigInt::Random::OO \-> new(min => \-2,
\&                                            max =>  3);
.Ve
.Sp
The following parameters are recognized.
.RS 4
.IP "min => \s-1NUM\s0" 4
.IX Item "min => NUM"
Specifies the minimum possible output value, i.e., the lower bound. If `max' is
given, but `min' is not, then `min' is set to zero.
.IP "max => \s-1NUM\s0" 4
.IX Item "max => NUM"
Specifies the maximum possible output value, i.e., the upper bound. If `max' is
given, but `min' is not, then `max' must be non-negative.
.IP "length => \s-1NUM\s0" 4
.IX Item "length => NUM"
Specifies the length of the output value, i.e., the number of digits. Use this
option to ensure that all random numbers have the same number of digits. If the
base is not given explicitly with the `base' option, then a base of 10 is used.
The following two constructors are equivalent
.Sp
.Vb 1
\&  Math::BigInt::Random::OO \-> new(length => $n, base => $b);
\&
\&  $min = Math::BigInt \-> new($b) \-> bpow($n \- 1);
\&  $max = Math::BigInt \-> new($b) \-> bpow($n) \-> bsub(1));
\&  Math::BigInt::Random::OO \-> new(min => $min, max => $max);
.Ve
.Sp
For instance, if the length is 4 and the base is 10, the random numbers will be
in the range from 1000 to 9999, inclusive. If the length is 3 and the base is
16, the random numbers will be in the range from 256 to 4095, which is 100 to
fff hexadecimal.
.Sp
This option is ignored if the `max' option is present.
.IP "base => \s-1NUM\s0" 4
.IX Item "base => NUM"
Sets the base to be used with the `length' option. See also the description for
the `length' option.
.IP "length_bin => \s-1NUM\s0" 4
.IX Item "length_bin => NUM"
This option is only for compatibility with Math::BigInt::Random. The following
two cases are equivalent
.Sp
.Vb 2
\&  $cls \-> new(length_bin => $n);
\&  $cls \-> new(length => $n, base => 2);
.Ve
.IP "length_hex => \s-1NUM\s0" 4
.IX Item "length_hex => NUM"
This option is only for compatibility with Math::BigInt::Random. The following
two cases are equivalent
.Sp
.Vb 2
\&  $cls \-> new(length_hex => $n);
\&  $cls \-> new(length => $n, base => 16);
.Ve
.RE
.RS 4
.RE
.IP "\s-1OBJECT\s0 \-> generate ( \s-1COUNT\s0 )" 4
.IX Item "OBJECT -> generate ( COUNT )"
.PD 0
.IP "\s-1OBJECT\s0 \-> generate ( )" 4
.IX Item "OBJECT -> generate ( )"
.PD
Generates the given number of random numbers, or one number, if no input
argument is given.
.Sp
.Vb 1
\&  # Generate ten random numbers:
\&
\&  my @num = $gen \-> generate(10);
.Ve
.SH "TODO"
.IX Header "TODO"
.IP "\(bu" 4
Add a way to change the core uniform random number generator. Currently,
\&\fICORE::rand()\fR is used, but it would be nice to be able to switch to, e.g.,
\&\fIMath::Random::random_uniform_integer()\fR.
.IP "\(bu" 4
Add functionality similar to the `use_internet' parameter argument in
\&\fIMath::BigInt::Rando::random_bigint()\fR. This could be implemented using, e.g.,
Net::Random.
.IP "\(bu" 4
Add more tests.
.SH "NOTES"
.IX Header "NOTES"
To fully understand how Math::BigInt::Random::OO works, one must understand how
Perl's \fICORE::rand()\fR works.
.SS "Details on \fICORE::rand()\fP"
.IX Subsection "Details on CORE::rand()"
\&\fICORE::rand()\fR is Perl's own function for generating uniformly distributed
pseudo-random integers. The core of \fICORE::rand()\fR is an internal function, let's
call it \s-1\fIRAND\s0()\fR, which generates uniformly distributed pseudo-random integers
greater than or equal to 0 and less 2**\fI\s-1RANDBITS\s0\fR. \fICORE::rand()\fR is implemented
equivalently to
.PP
.Vb 3
\&                     K * RAND()
\&  CORE::rand(K) = \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&                   2 ** RANDBITS
.Ve
.PP
One may think of the output of \s-1\fIRAND\s0()\fR as a integer consisting of \fI\s-1RANDBITS\s0\fR
bits, where each bit is 0 or 1 with a 50% chance of each. To get a random
integer with all \fI\s-1RANDBITS\s0\fR bits, one must use
.PP
.Vb 1
\&  CORE::rand(2 ** RANDBITS)
.Ve
.PP
Similarely, to get the first \fIN\fR bits, where \fIN\fR must be less than or equal
to \fI\s-1RANDBITS\s0\fR, use
.PP
.Vb 1
\&  int CORE::rand(2 ** N)
.Ve
.PP
The commonly used idiom for generating a random integer in Perl,
.PP
.Vb 1
\&  int CORE::rand(K)
.Ve
.PP
only returns uniformly distributed numbers when \fIK\fR is a power of two no lager
than \fI\s-1RANDBITS\s0\fR.
.PP
You can see the number of \fI\s-1RANDBITS\s0\fR in your Perl with
.PP
.Vb 2
\&  use Config;
\&  print $Config{randbits};
.Ve
.PP
or on the command line with
.PP
.Vb 1
\&  perl \-MConfig \-wle \*(Aqprint $Config{randbits}\*(Aq
.Ve
.PP
or, in new versions of Perl, also
.PP
.Vb 1
\&  perl \-V:randbits
.Ve
.SS "More on Math::BigInt::Random::OO \-> \fIgenerate()\fP"
.IX Subsection "More on Math::BigInt::Random::OO -> generate()"
The goal is to generate a uniformly distributed random integer \fIX\fR greater
than or equal to \fIXmin\fR and less than or equal to \fIXmax\fR. The core of the
\&\fIgenerate()\fR method is an algorithm that generates a uniformly distributed
non-negative random integer \fIU\fR < 2**\fIN\fR, where \fIN\fR is the smallest
integer so that 2**\fIN\fR is larger than the range \fIR\fR = \fIXmin\fR \- \fIXmax\fR.
Equivalently, \fIN\fR = 1 + int(log(\fIR\fR)/\fIlog\fR\|(2)). If the generated integer \fIU\fR
is larger than \fIR\fR, that value is rejected and a new \fIU\fR is generated. This
is done until \fIU\fR is less than or equal to \fIR\fR. When a \fIU\fR is accepted, \fIX\fR
= \fIU\fR \- \fIXmin\fR is returned.
.PP
A uniformly distributed non-negative random integer \fIU\fR < 2**\fIN\fR is
generated by combining smaller uniformly distributed non-negative random
integer \fIV\fR < 2**\fIM\fR, where \fIM\fR less than or equal to \fI\s-1RANDBITS\s0\fR. Each
of the smaller random integers is generated with \fICORE::rand()\fR.
.PP
Here is an example: Assume \fI\s-1RANDBITS\s0\fR is 15, which is not uncommon, and the
range is 10,000,000,000. The smallest power of two larger than 10,000,000,000
is 2**34 = 17,179,869,184. Since 34 is 4 + 15 + 15, a uniformly distributed
non-negative random integer \fIU\fR < 17,179,869,184 is generated by combining
three uniformly distributed non-negative random integers, \fIU2\fR < 2**4,
\&\fIU1\fR < 2**15, and \fIU0\fR < 2**15.
.PP
The following Perl code handles this special case, and produces a uniformly
distributed random integer \fIU\fR greater than or equal to \fIR\fR:
.PP
.Vb 1
\&  $R = Math::BigInt\->new(\*(Aq10_000_000_000\*(Aq);   # range
\&
\&  do {
\&      $U2 = Math::BigInt\->new(int CORE::rand 2**4);
\&      $U1 = Math::BigInt\->new(int CORE::rand 2**15);
\&      $U0 = Math::BigInt\->new(int CORE::rand 2**15);
\&      $U  = (($U2 * 2**15) + $U1) * 2**15 + $U0;
\&  } until $U <= $R;
.Ve
.SS "Problems with Math::BigInt::Random"
.IX Subsection "Problems with Math::BigInt::Random"
I wrote this module partly since Math::BigInt::Random v0.04 is buggy, and in
many cases slower, and partly because I prefer an object-oriented interface.
The bugs in Math::BigInt::Random v0.04 are
.IP "\(bu" 4
When the range (the maximum value minus the minimum value) is smaller than
1048575 (fffff hexadecimal), the maximum value will never be returned.
.IP "\(bu" 4
When Perl has been compiled with a number of \fI\s-1RANDBITS\s0\fR less than 20, certain
values will never occur.
.IP "\(bu" 4
When the range is not a power of two, certain values are more likely to occur
than others.
.PP
The core of this two last problems is the use of int(rand(X)), which only
returns uniformly distributed numbers when X is a power of two no larger than
\&\fI\s-1RANDBITS\s0\fR.
.PP
In addition, the function \fIMath::BigInt::Random::random_bigint()\fR generates only
one random integer at a time, and in doing so, there is some overhead. In
Math::BigInt::Random::OO, this overhead is placed in the \fInew()\fR constructor, so
it is done only once, independently of how many random numbers are generated by
the \fIgenerator()\fR method.
.SH "CAVEATS"
.IX Header "CAVEATS"
.IP "\(bu" 4
Some versions of Perl are compiled with the wrong number of \fI\s-1RANDBITS\s0\fR. This
module has way to detect if this is the case.
.IP "\(bu" 4
Some versions of \fICORE::rand()\fR behave poorly. For intance, in some
implementations
.Sp
.Vb 1
\&  rand(1 << $Config{randbits}) % 2
.Ve
.Sp
alternates between 0 and 1 deterministically.
.SH "BUGS"
.IX Header "BUGS"
There are currently no known bugs.
.PP
Please report any bugs or feature requests to
\&\f(CW\*(C`bug\-math\-bigint\-random\-oo at rt.cpan.org\*(C'\fR, or through the web interface
at <http://rt.cpan.org/Public/Bug/Report.html?Queue=Math\-BigInt\-Random\-OO>
I will be notified, and then you'll automatically be notified of progress on
your bug as I make changes.
.SH "SUPPORT"
.IX Header "SUPPORT"
You can find documentation for this module with the perldoc command.
.PP
.Vb 1
\&  perldoc Math::BigInt::Random::OO
.Ve
.PP
You can also look for information at:
.IP "\(bu" 4
\&\s-1RT:\s0 \s-1CPAN\s0's request tracker
.Sp
<http://rt.cpan.org/Public/Dist/Display.html?Name=Math\-BigInt\-Random\-OO>
.IP "\(bu" 4
\&\s-1CPAN\s0 Ratings
.Sp
<http://cpanratings.perl.org/dist/Math\-BigInt\-Random\-OO>
.IP "\(bu" 4
Search \s-1CPAN\s0
.Sp
<http://search.cpan.org/dist/Math\-BigInt\-Random\-OO>
.IP "\(bu" 4
\&\s-1CPAN\s0 Testers \s-1PASS\s0 Matrix
.Sp
<http://pass.cpantesters.org/distro/M/Math\-BigInt\-Random\-OO.html>
.IP "\(bu" 4
\&\s-1CPAN\s0 Testers Reports
.Sp
<http://www.cpantesters.org/distro/M/Math\-BigInt\-Random\-OO.html>
.IP "\(bu" 4
\&\s-1CPAN\s0 Testers Matrix
.Sp
<http://matrix.cpantesters.org/?dist=Math\-BigInt\-Random\-OO>
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\fIMath::BigInt::Random\fR\|(3), \fIMath::Random\fR\|(3), \fINet::Random\fR\|(3).
.SH "AUTHOR"
.IX Header "AUTHOR"
Peter John Acklam, <pjacklam@cpan.org>
.SH "COPYRIGHT & LICENSE"
.IX Header "COPYRIGHT & LICENSE"
Copyright 2010 by Peter John Acklam <pjacklam@cpan.org>
.PP
This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself, either Perl version 5.8.0 or,
at your option, any later version of Perl 5 you may have available.
